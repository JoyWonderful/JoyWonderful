# this code is generated by deepseek
import random
from typing import List, Tuple

# 生成一些重复的成绩模式
def generate_score_patterns(num_patterns: int) -> List[List[float]]:
    patterns = []
    for _ in range(num_patterns):
        # 生成5个成绩
        scores = []
        for j in range(5):
            # 随机决定是整数还是小数
            if random.random() < 0.6:  # 60%的概率生成小数
                score = round(random.uniform(0.0, 180.0), 1)
            else:
                score = float(random.randint(0, 180))
            scores.append(score)
        patterns.append(scores)
    return patterns

# 生成姓名（确保中、英、中英文混合都有）
def generate_name(index: int) -> str:
    # 确保三种类型都出现
    name_type = index % 3
    
    if name_type == 0:  # 纯英文
        first_names = ["John", "Emma", "Michael", "Sophia", "David", "Olivia", "James", "Ava", "Robert", "Mia"]
        last_names = ["Smith", "Johnson", "Brown", "Taylor", "Miller", "Wilson", "Davis", "Anderson", "Thomas", "Jackson"]
        return f"{random.choice(first_names)}{random.choice(last_names)}"
    
    elif name_type == 1:  # 纯中文
        chinese_names = ["张三", "李四", "王五", "赵六", "钱七", "孙八", "周九", "吴十", "郑十一", "王十二"]
        return random.choice(chinese_names)
    
    else:  # 中英文混合
        english_parts = ["Alex", "Tom", "Lucy", "Chris", "Grace", "Leo", "Ruby", "Sam", "Lily", "Max"]
        chinese_parts = ["张", "李", "王", "赵", "钱", "孙", "周", "吴", "郑", "刘"]
        return f"{random.choice(english_parts)}{random.choice(chinese_parts)}"

# 生成数据
def generate_data_blocks(num_blocks: int = 250) -> List[str]:
    # 生成一些重复的成绩模式（约50个不同的模式）
    score_patterns = generate_score_patterns(50)
    
    # 存储已使用的学号
    used_ids = set()
    # 存储总分及其出现的次数
    total_score_counts = {}
    
    data_blocks = []
    
    for block_idx in range(num_blocks):
        block = []
        
        # 第一行：固定为1
        block.append("1")
        
        # 第二行：学号（不重复）
        student_id = block_idx
        block.append(str(student_id))
        
        # 第三行：姓名
        name = generate_name(block_idx)
        block.append(name)
        
        # 第四行：班级（1-9999，应该有重复）
        # 让班级集中在某些范围内以增加重复概率
        cla = random.choice([101, 102, 103, 201, 202, 203, 301, 302, 303])
        block.append(str(cla))
        
        # 第5-9行：成绩
        # 随机选择一个成绩模式
        pattern_idx = block_idx % len(score_patterns)  # 确保模式会重复
        scores = score_patterns[pattern_idx]
        
        # 计算总分
        total_score = sum(scores)
        
        # 记录总分出现次数
        total_score_counts[total_score] = total_score_counts.get(total_score, 0) + 1
        
        # 添加成绩行
        for score in scores:
            block.append(f"{score:.1f}" if isinstance(score, float) and score != int(score) else str(int(score)))
        
        data_blocks.append(block)
    
    # 验证总分重复性
    repeated_totals = [score for score, count in total_score_counts.items() if count > 1]
    print(f"生成完成！共有{len(repeated_totals)}个不同的总分被重复使用")
    
    return data_blocks

# 生成250个数据块
data_blocks = generate_data_blocks(250)

# 输出数据
output_lines = []
for block in data_blocks:
    output_lines.extend(block)

# 输出示例（前几个数据块）
print("生成的数据示例（前45行，即5个完整数据块）：")
print("\n".join(output_lines[:45]))
print("\n... 共", len(output_lines), "行数据")

# 也可以保存到文件
with open("input.in", "w", encoding="utf-8") as f:
    for i, line in enumerate(output_lines):
        f.write(line)
        if (i + 1) % 9 != 0:  # 不是每个数据块的最后一行
            f.write("\n")
        elif i + 1 != len(output_lines):  # 不是最后一行
            f.write("\n")

print("\n数据已保存到 test_data.txt 文件中")